"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./src/lib/courseService.ts":
/*!**********************************!*\
  !*** ./src/lib/courseService.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CourseService: function() { return /* binding */ CourseService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/storage */ \"(app-pages-browser)/./node_modules/firebase/storage/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n// src/lib/courseService.ts\n\n\n\n\nconst COLLECTION_NAME = \"courses\";\n// Helper function to clean data before sending to Firestore\nconst cleanCourseData = (data)=>{\n    const cleaned = {};\n    for (const [key, value] of Object.entries(data)){\n        // Skip undefined values and functions\n        if (value !== undefined && typeof value !== \"function\") {\n            // Convert empty strings to null for optional fields\n            if (typeof value === \"string\" && value === \"\" && [\n                \"paymentLink\",\n                \"backgroundImage\",\n                \"certificateImage\"\n            ].includes(key)) {\n                cleaned[key] = null;\n            } else {\n                cleaned[key] = value;\n            }\n        }\n    }\n    return cleaned;\n};\nclass CourseService {\n    // Create a new course\n    static async createCourse(courseData) {\n        try {\n            const courseId = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n            const courseWithMetadata = {\n                ...courseData,\n                _id: courseId,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                status: courseData.status || \"draft\",\n                // Ensure these fields are numbers\n                rating: Number(courseData.rating) || 0,\n                totalRatings: Number(courseData.totalRatings) || 0,\n                enrolledStudents: Number(courseData.enrolledStudents) || 0,\n                price: Number(courseData.price) || 0,\n                originalPrice: Number(courseData.originalPrice) || 0,\n                // Ensure arrays are properly initialized\n                learningOutcomes: Array.isArray(courseData.learningOutcomes) ? courseData.learningOutcomes : [],\n                features: Array.isArray(courseData.features) ? courseData.features : [],\n                skills: Array.isArray(courseData.skills) ? courseData.skills : [],\n                requirements: Array.isArray(courseData.requirements) ? courseData.requirements : [],\n                module: Array.isArray(courseData.module) ? courseData.module : [],\n                highlights: Array.isArray(courseData.highlights) ? courseData.highlights : [],\n                project: Array.isArray(courseData.project) ? courseData.project : [],\n                programFor: Array.isArray(courseData.programFor) ? courseData.programFor : []\n            };\n            // Clean the data before sending\n            const cleanedData = cleanCourseData(courseWithMetadata);\n            console.log(\"Creating course with data:\", cleanedData);\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, COLLECTION_NAME), cleanedData);\n            const createdCourse = {\n                ...cleanedData,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            };\n            return {\n                success: true,\n                data: createdCourse\n            };\n        } catch (error) {\n            console.error(\"Error creating course:\", error);\n            (0,_firebase__WEBPACK_IMPORTED_MODULE_2__.handleFirestoreError)(error);\n            return {\n                success: false,\n                error: error.message || \"Failed to create course\"\n            };\n        }\n    }\n    // Get all courses\n    static async getAllCourses() {\n        try {\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.orderBy)(\"createdAt\", \"desc\"));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            const courses = [];\n            querySnapshot.forEach((doc)=>{\n                var _data_createdAt, _data_updatedAt;\n                const data = doc.data();\n                courses.push({\n                    ...data,\n                    createdAt: (_data_createdAt = data.createdAt) === null || _data_createdAt === void 0 ? void 0 : _data_createdAt.toDate(),\n                    updatedAt: (_data_updatedAt = data.updatedAt) === null || _data_updatedAt === void 0 ? void 0 : _data_updatedAt.toDate()\n                });\n            });\n            return {\n                success: true,\n                data: courses\n            };\n        } catch (error) {\n            console.error(\"Error fetching courses:\", error);\n            (0,_firebase__WEBPACK_IMPORTED_MODULE_2__.handleFirestoreError)(error);\n            return {\n                success: false,\n                error: error.message || \"Failed to fetch courses\"\n            };\n        }\n    }\n    // Get course by ID\n    static async getCourseById(courseId) {\n        try {\n            var _data_createdAt, _data_updatedAt;\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"_id\", \"==\", courseId));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            if (querySnapshot.empty) {\n                return {\n                    success: false,\n                    error: \"Course not found\"\n                };\n            }\n            const doc = querySnapshot.docs[0];\n            const data = doc.data();\n            const course = {\n                ...data,\n                createdAt: (_data_createdAt = data.createdAt) === null || _data_createdAt === void 0 ? void 0 : _data_createdAt.toDate(),\n                updatedAt: (_data_updatedAt = data.updatedAt) === null || _data_updatedAt === void 0 ? void 0 : _data_updatedAt.toDate()\n            };\n            return {\n                success: true,\n                data: course\n            };\n        } catch (error) {\n            console.error(\"Error fetching course:\", error);\n            (0,_firebase__WEBPACK_IMPORTED_MODULE_2__.handleFirestoreError)(error);\n            return {\n                success: false,\n                error: error.message || \"Failed to fetch course\"\n            };\n        }\n    }\n    // Update course\n    static async updateCourse(courseId, courseData) {\n        try {\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"_id\", \"==\", courseId));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            if (querySnapshot.empty) {\n                return {\n                    success: false,\n                    error: \"Course not found\"\n                };\n            }\n            const docRef = querySnapshot.docs[0].ref;\n            const updateData = {\n                ...courseData,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                // Ensure numeric fields are properly typed\n                ...courseData.rating !== undefined && {\n                    rating: Number(courseData.rating)\n                },\n                ...courseData.totalRatings !== undefined && {\n                    totalRatings: Number(courseData.totalRatings)\n                },\n                ...courseData.enrolledStudents !== undefined && {\n                    enrolledStudents: Number(courseData.enrolledStudents)\n                },\n                ...courseData.price !== undefined && {\n                    price: Number(courseData.price)\n                },\n                ...courseData.originalPrice !== undefined && {\n                    originalPrice: Number(courseData.originalPrice)\n                }\n            };\n            // Clean the data before sending\n            const cleanedData = cleanCourseData(updateData);\n            console.log(\"Updating course with data:\", cleanedData);\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.updateDoc)(docRef, cleanedData);\n            const updatedCourse = {\n                ...courseData,\n                _id: courseId,\n                updatedAt: new Date()\n            };\n            return {\n                success: true,\n                data: updatedCourse\n            };\n        } catch (error) {\n            console.error(\"Error updating course:\", error);\n            (0,_firebase__WEBPACK_IMPORTED_MODULE_2__.handleFirestoreError)(error);\n            return {\n                success: false,\n                error: error.message || \"Failed to update course\"\n            };\n        }\n    }\n    // Delete course\n    static async deleteCourse(courseId) {\n        try {\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(_firebase__WEBPACK_IMPORTED_MODULE_2__.db, COLLECTION_NAME), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.where)(\"_id\", \"==\", courseId));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)(q);\n            if (querySnapshot.empty) {\n                return {\n                    success: false,\n                    error: \"Course not found\"\n                };\n            }\n            const docRef = querySnapshot.docs[0].ref;\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.deleteDoc)(docRef);\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(\"Error deleting course:\", error);\n            (0,_firebase__WEBPACK_IMPORTED_MODULE_2__.handleFirestoreError)(error);\n            return {\n                success: false,\n                error: error.message || \"Failed to delete course\"\n            };\n        }\n    }\n    // Upload image with better error handling\n    static async uploadImage(file, path) {\n        try {\n            // Validate file\n            if (!file) {\n                return {\n                    success: false,\n                    error: \"No file provided\"\n                };\n            }\n            if (file.size > 5 * 1024 * 1024) {\n                return {\n                    success: false,\n                    error: \"File size must be less than 5MB\"\n                };\n            }\n            const allowedTypes = [\n                \"image/jpeg\",\n                \"image/png\",\n                \"image/webp\"\n            ];\n            if (!allowedTypes.includes(file.type)) {\n                return {\n                    success: false,\n                    error: \"Only JPEG, PNG, and WebP images are allowed\"\n                };\n            }\n            const filename = \"\".concat(Date.now(), \"_\").concat(file.name.replace(/[^a-zA-Z0-9.-]/g, \"_\"));\n            const storageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, \"\".concat(path, \"/\").concat(filename));\n            console.log(\"Uploading image:\", filename);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.uploadBytes)(storageRef, file);\n            const downloadURL = await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.getDownloadURL)(storageRef);\n            return {\n                success: true,\n                url: downloadURL\n            };\n        } catch (error) {\n            console.error(\"Error uploading image:\", error);\n            return {\n                success: false,\n                error: error.message || \"Failed to upload image\"\n            };\n        }\n    }\n    // Delete image\n    static async deleteImage(imageUrl) {\n        try {\n            const imageRef = (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.ref)(_firebase__WEBPACK_IMPORTED_MODULE_2__.storage, imageUrl);\n            await (0,firebase_storage__WEBPACK_IMPORTED_MODULE_1__.deleteObject)(imageRef);\n            return {\n                success: true\n            };\n        } catch (error) {\n            console.error(\"Error deleting image:\", error);\n            return {\n                success: false,\n                error: error.message || \"Failed to delete image\"\n            };\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY291cnNlU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLDJCQUEyQjtBQWNDO0FBQ3NEO0FBQ25CO0FBRTNCO0FBRXBDLE1BQU1rQixrQkFBa0I7QUFFeEIsNERBQTREO0FBQzVELE1BQU1DLGtCQUFrQixDQUFDQztJQUN2QixNQUFNQyxVQUFlLENBQUM7SUFFdEIsS0FBSyxNQUFNLENBQUNDLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDTCxNQUFPO1FBQy9DLHNDQUFzQztRQUN0QyxJQUFJRyxVQUFVRyxhQUFhLE9BQU9ILFVBQVUsWUFBWTtZQUN0RCxvREFBb0Q7WUFDcEQsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsTUFDdkM7Z0JBQUM7Z0JBQWU7Z0JBQW1CO2FBQW1CLENBQUNJLFFBQVEsQ0FBQ0wsTUFBTTtnQkFDeEVELE9BQU8sQ0FBQ0MsSUFBSSxHQUFHO1lBQ2pCLE9BQU87Z0JBQ0xELE9BQU8sQ0FBQ0MsSUFBSSxHQUFHQztZQUNqQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPRjtBQUNUO0FBRU8sTUFBTU87SUFDWCxzQkFBc0I7SUFDdEIsYUFBYUMsYUFBYUMsVUFBcUIsRUFBMkI7UUFDeEUsSUFBSTtZQUNGLE1BQU1DLFdBQVdkLGdEQUFNQTtZQUV2QixNQUFNZSxxQkFBcUI7Z0JBQ3pCLEdBQUdGLFVBQVU7Z0JBQ2JHLEtBQUtGO2dCQUNMRyxXQUFXM0IsbUVBQWVBO2dCQUMxQjRCLFdBQVc1QixtRUFBZUE7Z0JBQzFCNkIsUUFBUU4sV0FBV00sTUFBTSxJQUFJO2dCQUM3QixrQ0FBa0M7Z0JBQ2xDQyxRQUFRQyxPQUFPUixXQUFXTyxNQUFNLEtBQUs7Z0JBQ3JDRSxjQUFjRCxPQUFPUixXQUFXUyxZQUFZLEtBQUs7Z0JBQ2pEQyxrQkFBa0JGLE9BQU9SLFdBQVdVLGdCQUFnQixLQUFLO2dCQUN6REMsT0FBT0gsT0FBT1IsV0FBV1csS0FBSyxLQUFLO2dCQUNuQ0MsZUFBZUosT0FBT1IsV0FBV1ksYUFBYSxLQUFLO2dCQUNuRCx5Q0FBeUM7Z0JBQ3pDQyxrQkFBa0JDLE1BQU1DLE9BQU8sQ0FBQ2YsV0FBV2EsZ0JBQWdCLElBQUliLFdBQVdhLGdCQUFnQixHQUFHLEVBQUU7Z0JBQy9GRyxVQUFVRixNQUFNQyxPQUFPLENBQUNmLFdBQVdnQixRQUFRLElBQUloQixXQUFXZ0IsUUFBUSxHQUFHLEVBQUU7Z0JBQ3ZFQyxRQUFRSCxNQUFNQyxPQUFPLENBQUNmLFdBQVdpQixNQUFNLElBQUlqQixXQUFXaUIsTUFBTSxHQUFHLEVBQUU7Z0JBQ2pFQyxjQUFjSixNQUFNQyxPQUFPLENBQUNmLFdBQVdrQixZQUFZLElBQUlsQixXQUFXa0IsWUFBWSxHQUFHLEVBQUU7Z0JBQ25GQyxRQUFRTCxNQUFNQyxPQUFPLENBQUNmLFdBQVdtQixNQUFNLElBQUluQixXQUFXbUIsTUFBTSxHQUFHLEVBQUU7Z0JBQ2pFQyxZQUFZTixNQUFNQyxPQUFPLENBQUNmLFdBQVdvQixVQUFVLElBQUlwQixXQUFXb0IsVUFBVSxHQUFHLEVBQUU7Z0JBQzdFQyxTQUFTUCxNQUFNQyxPQUFPLENBQUNmLFdBQVdxQixPQUFPLElBQUlyQixXQUFXcUIsT0FBTyxHQUFHLEVBQUU7Z0JBQ3BFQyxZQUFZUixNQUFNQyxPQUFPLENBQUNmLFdBQVdzQixVQUFVLElBQUl0QixXQUFXc0IsVUFBVSxHQUFHLEVBQUU7WUFDL0U7WUFFQSxnQ0FBZ0M7WUFDaEMsTUFBTUMsY0FBY2xDLGdCQUFnQmE7WUFFcENzQixRQUFRQyxHQUFHLENBQUMsOEJBQThCRjtZQUUxQyxNQUFNRyxTQUFTLE1BQU12RCwwREFBTUEsQ0FBQ0QsOERBQVVBLENBQUNhLHlDQUFFQSxFQUFFSyxrQkFBa0JtQztZQUU3RCxNQUFNSSxnQkFBd0I7Z0JBQzVCLEdBQUdKLFdBQVc7Z0JBQ2RuQixXQUFXLElBQUl3QjtnQkFDZnZCLFdBQVcsSUFBSXVCO1lBQ2pCO1lBRUEsT0FBTztnQkFDTEMsU0FBUztnQkFDVHZDLE1BQU1xQztZQUNSO1FBQ0YsRUFBRSxPQUFPRyxPQUFZO1lBQ25CTixRQUFRTSxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QzdDLCtEQUFvQkEsQ0FBQzZDO1lBQ3JCLE9BQU87Z0JBQ0xELFNBQVM7Z0JBQ1RDLE9BQU9BLE1BQU1DLE9BQU8sSUFBSTtZQUMxQjtRQUNGO0lBQ0Y7SUFFQSxrQkFBa0I7SUFDbEIsYUFBYUMsZ0JBQTBDO1FBQ3JELElBQUk7WUFDRixNQUFNQyxJQUFJMUQseURBQUtBLENBQUNMLDhEQUFVQSxDQUFDYSx5Q0FBRUEsRUFBRUssa0JBQWtCWiwyREFBT0EsQ0FBQyxhQUFhO1lBQ3RFLE1BQU0wRCxnQkFBZ0IsTUFBTTVELDJEQUFPQSxDQUFDMkQ7WUFFcEMsTUFBTUUsVUFBb0IsRUFBRTtZQUM1QkQsY0FBY0UsT0FBTyxDQUFDLENBQUNDO29CQUlSL0MsaUJBQ0FBO2dCQUpiLE1BQU1BLE9BQU8rQyxJQUFJL0MsSUFBSTtnQkFDckI2QyxRQUFRRyxJQUFJLENBQUM7b0JBQ1gsR0FBR2hELElBQUk7b0JBQ1BjLFNBQVMsR0FBRWQsa0JBQUFBLEtBQUtjLFNBQVMsY0FBZGQsc0NBQUFBLGdCQUFnQmlELE1BQU07b0JBQ2pDbEMsU0FBUyxHQUFFZixrQkFBQUEsS0FBS2UsU0FBUyxjQUFkZixzQ0FBQUEsZ0JBQWdCaUQsTUFBTTtnQkFDbkM7WUFDRjtZQUVBLE9BQU87Z0JBQ0xWLFNBQVM7Z0JBQ1R2QyxNQUFNNkM7WUFDUjtRQUNGLEVBQUUsT0FBT0wsT0FBWTtZQUNuQk4sUUFBUU0sS0FBSyxDQUFDLDJCQUEyQkE7WUFDekM3QywrREFBb0JBLENBQUM2QztZQUNyQixPQUFPO2dCQUNMRCxTQUFTO2dCQUNUQyxPQUFPQSxNQUFNQyxPQUFPLElBQUk7WUFDMUI7UUFDRjtJQUNGO0lBRUEsbUJBQW1CO0lBQ25CLGFBQWFTLGNBQWN2QyxRQUFnQixFQUEyQjtRQUNwRSxJQUFJO2dCQWVXWCxpQkFDQUE7WUFmYixNQUFNMkMsSUFBSTFELHlEQUFLQSxDQUFDTCw4REFBVUEsQ0FBQ2EseUNBQUVBLEVBQUVLLGtCQUFrQlYseURBQUtBLENBQUMsT0FBTyxNQUFNdUI7WUFDcEUsTUFBTWlDLGdCQUFnQixNQUFNNUQsMkRBQU9BLENBQUMyRDtZQUVwQyxJQUFJQyxjQUFjTyxLQUFLLEVBQUU7Z0JBQ3ZCLE9BQU87b0JBQ0xaLFNBQVM7b0JBQ1RDLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLE1BQU1PLE1BQU1ILGNBQWNRLElBQUksQ0FBQyxFQUFFO1lBQ2pDLE1BQU1wRCxPQUFPK0MsSUFBSS9DLElBQUk7WUFDckIsTUFBTXFELFNBQWlCO2dCQUNyQixHQUFHckQsSUFBSTtnQkFDUGMsU0FBUyxHQUFFZCxrQkFBQUEsS0FBS2MsU0FBUyxjQUFkZCxzQ0FBQUEsZ0JBQWdCaUQsTUFBTTtnQkFDakNsQyxTQUFTLEdBQUVmLGtCQUFBQSxLQUFLZSxTQUFTLGNBQWRmLHNDQUFBQSxnQkFBZ0JpRCxNQUFNO1lBQ25DO1lBRUEsT0FBTztnQkFDTFYsU0FBUztnQkFDVHZDLE1BQU1xRDtZQUNSO1FBQ0YsRUFBRSxPQUFPYixPQUFZO1lBQ25CTixRQUFRTSxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QzdDLCtEQUFvQkEsQ0FBQzZDO1lBQ3JCLE9BQU87Z0JBQ0xELFNBQVM7Z0JBQ1RDLE9BQU9BLE1BQU1DLE9BQU8sSUFBSTtZQUMxQjtRQUNGO0lBQ0Y7SUFFQSxnQkFBZ0I7SUFDaEIsYUFBYWEsYUFBYTNDLFFBQWdCLEVBQUVELFVBQTJCLEVBQTJCO1FBQ2hHLElBQUk7WUFDRixNQUFNaUMsSUFBSTFELHlEQUFLQSxDQUFDTCw4REFBVUEsQ0FBQ2EseUNBQUVBLEVBQUVLLGtCQUFrQlYseURBQUtBLENBQUMsT0FBTyxNQUFNdUI7WUFDcEUsTUFBTWlDLGdCQUFnQixNQUFNNUQsMkRBQU9BLENBQUMyRDtZQUVwQyxJQUFJQyxjQUFjTyxLQUFLLEVBQUU7Z0JBQ3ZCLE9BQU87b0JBQ0xaLFNBQVM7b0JBQ1RDLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLE1BQU1KLFNBQVNRLGNBQWNRLElBQUksQ0FBQyxFQUFFLENBQUMvRCxHQUFHO1lBRXhDLE1BQU1rRSxhQUFhO2dCQUNqQixHQUFHN0MsVUFBVTtnQkFDYkssV0FBVzVCLG1FQUFlQTtnQkFDMUIsMkNBQTJDO2dCQUMzQyxHQUFJdUIsV0FBV08sTUFBTSxLQUFLWCxhQUFhO29CQUFFVyxRQUFRQyxPQUFPUixXQUFXTyxNQUFNO2dCQUFFLENBQUM7Z0JBQzVFLEdBQUlQLFdBQVdTLFlBQVksS0FBS2IsYUFBYTtvQkFBRWEsY0FBY0QsT0FBT1IsV0FBV1MsWUFBWTtnQkFBRSxDQUFDO2dCQUM5RixHQUFJVCxXQUFXVSxnQkFBZ0IsS0FBS2QsYUFBYTtvQkFBRWMsa0JBQWtCRixPQUFPUixXQUFXVSxnQkFBZ0I7Z0JBQUUsQ0FBQztnQkFDMUcsR0FBSVYsV0FBV1csS0FBSyxLQUFLZixhQUFhO29CQUFFZSxPQUFPSCxPQUFPUixXQUFXVyxLQUFLO2dCQUFFLENBQUM7Z0JBQ3pFLEdBQUlYLFdBQVdZLGFBQWEsS0FBS2hCLGFBQWE7b0JBQUVnQixlQUFlSixPQUFPUixXQUFXWSxhQUFhO2dCQUFFLENBQUM7WUFDbkc7WUFFQSxnQ0FBZ0M7WUFDaEMsTUFBTVcsY0FBY2xDLGdCQUFnQndEO1lBRXBDckIsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QkY7WUFFMUMsTUFBTW5ELDZEQUFTQSxDQUFDc0QsUUFBUUg7WUFFeEIsTUFBTXVCLGdCQUF3QjtnQkFDNUIsR0FBRzlDLFVBQVU7Z0JBQ2JHLEtBQUtGO2dCQUNMSSxXQUFXLElBQUl1QjtZQUNqQjtZQUVBLE9BQU87Z0JBQ0xDLFNBQVM7Z0JBQ1R2QyxNQUFNd0Q7WUFDUjtRQUNGLEVBQUUsT0FBT2hCLE9BQVk7WUFDbkJOLFFBQVFNLEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDN0MsK0RBQW9CQSxDQUFDNkM7WUFDckIsT0FBTztnQkFDTEQsU0FBUztnQkFDVEMsT0FBT0EsTUFBTUMsT0FBTyxJQUFJO1lBQzFCO1FBQ0Y7SUFDRjtJQUVBLGdCQUFnQjtJQUNoQixhQUFhZ0IsYUFBYTlDLFFBQWdCLEVBQWlEO1FBQ3pGLElBQUk7WUFDRixNQUFNZ0MsSUFBSTFELHlEQUFLQSxDQUFDTCw4REFBVUEsQ0FBQ2EseUNBQUVBLEVBQUVLLGtCQUFrQlYseURBQUtBLENBQUMsT0FBTyxNQUFNdUI7WUFDcEUsTUFBTWlDLGdCQUFnQixNQUFNNUQsMkRBQU9BLENBQUMyRDtZQUVwQyxJQUFJQyxjQUFjTyxLQUFLLEVBQUU7Z0JBQ3ZCLE9BQU87b0JBQ0xaLFNBQVM7b0JBQ1RDLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLE1BQU1KLFNBQVNRLGNBQWNRLElBQUksQ0FBQyxFQUFFLENBQUMvRCxHQUFHO1lBQ3hDLE1BQU1OLDZEQUFTQSxDQUFDcUQ7WUFFaEIsT0FBTztnQkFDTEcsU0FBUztZQUNYO1FBQ0YsRUFBRSxPQUFPQyxPQUFZO1lBQ25CTixRQUFRTSxLQUFLLENBQUMsMEJBQTBCQTtZQUN4QzdDLCtEQUFvQkEsQ0FBQzZDO1lBQ3JCLE9BQU87Z0JBQ0xELFNBQVM7Z0JBQ1RDLE9BQU9BLE1BQU1DLE9BQU8sSUFBSTtZQUMxQjtRQUNGO0lBQ0Y7SUFFQSwwQ0FBMEM7SUFDMUMsYUFBYWlCLFlBQVlDLElBQVUsRUFBRUMsSUFBWSxFQUErRDtRQUM5RyxJQUFJO1lBQ0YsZ0JBQWdCO1lBQ2hCLElBQUksQ0FBQ0QsTUFBTTtnQkFDVCxPQUFPO29CQUFFcEIsU0FBUztvQkFBT0MsT0FBTztnQkFBbUI7WUFDckQ7WUFFQSxJQUFJbUIsS0FBS0UsSUFBSSxHQUFHLElBQUksT0FBTyxNQUFNO2dCQUMvQixPQUFPO29CQUFFdEIsU0FBUztvQkFBT0MsT0FBTztnQkFBa0M7WUFDcEU7WUFFQSxNQUFNc0IsZUFBZTtnQkFBQztnQkFBYztnQkFBYTthQUFhO1lBQzlELElBQUksQ0FBQ0EsYUFBYXZELFFBQVEsQ0FBQ29ELEtBQUtJLElBQUksR0FBRztnQkFDckMsT0FBTztvQkFBRXhCLFNBQVM7b0JBQU9DLE9BQU87Z0JBQThDO1lBQ2hGO1lBRUEsTUFBTXdCLFdBQVcsR0FBaUJMLE9BQWRyQixLQUFLMkIsR0FBRyxJQUFHLEtBQTZDLE9BQTFDTixLQUFLTyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxtQkFBbUI7WUFDdkUsTUFBTUMsYUFBYS9FLHFEQUFHQSxDQUFDSyw4Q0FBT0EsRUFBRSxHQUFXc0UsT0FBUkosTUFBSyxLQUFZLE9BQVRJO1lBRTNDOUIsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQjZCO1lBRWhDLE1BQU0xRSw2REFBV0EsQ0FBQzhFLFlBQVlUO1lBQzlCLE1BQU1VLGNBQWMsTUFBTTlFLGdFQUFjQSxDQUFDNkU7WUFFekMsT0FBTztnQkFDTDdCLFNBQVM7Z0JBQ1QrQixLQUFLRDtZQUNQO1FBQ0YsRUFBRSxPQUFPN0IsT0FBWTtZQUNuQk4sUUFBUU0sS0FBSyxDQUFDLDBCQUEwQkE7WUFDeEMsT0FBTztnQkFDTEQsU0FBUztnQkFDVEMsT0FBT0EsTUFBTUMsT0FBTyxJQUFJO1lBQzFCO1FBQ0Y7SUFDRjtJQUVBLGVBQWU7SUFDZixhQUFhOEIsWUFBWUMsUUFBZ0IsRUFBaUQ7UUFDeEYsSUFBSTtZQUNGLE1BQU1DLFdBQVdwRixxREFBR0EsQ0FBQ0ssOENBQU9BLEVBQUU4RTtZQUM5QixNQUFNaEYsOERBQVlBLENBQUNpRjtZQUVuQixPQUFPO2dCQUNMbEMsU0FBUztZQUNYO1FBQ0YsRUFBRSxPQUFPQyxPQUFZO1lBQ25CTixRQUFRTSxLQUFLLENBQUMseUJBQXlCQTtZQUN2QyxPQUFPO2dCQUNMRCxTQUFTO2dCQUNUQyxPQUFPQSxNQUFNQyxPQUFPLElBQUk7WUFDMUI7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jb3Vyc2VTZXJ2aWNlLnRzPzM3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2xpYi9jb3Vyc2VTZXJ2aWNlLnRzXG5pbXBvcnQgeyBcbiAgY29sbGVjdGlvbiwgXG4gIGFkZERvYywgXG4gIHVwZGF0ZURvYywgXG4gIGRlbGV0ZURvYywgXG4gIGdldERvY3MsIFxuICBkb2MsIFxuICBnZXREb2MsXG4gIHF1ZXJ5LFxuICBvcmRlckJ5LFxuICBzZXJ2ZXJUaW1lc3RhbXAsXG4gIHdoZXJlLFxuICB3cml0ZUJhdGNoXG59IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5pbXBvcnQgeyByZWYsIHVwbG9hZEJ5dGVzLCBnZXREb3dubG9hZFVSTCwgZGVsZXRlT2JqZWN0IH0gZnJvbSAnZmlyZWJhc2Uvc3RvcmFnZSc7XG5pbXBvcnQgeyBkYiwgc3RvcmFnZSwgaGFuZGxlRmlyZXN0b3JlRXJyb3IgfSBmcm9tICcuL2ZpcmViYXNlJztcbmltcG9ydCB7IENvdXJzZSwgTmV3Q291cnNlLCBDb3Vyc2VzUmVzcG9uc2UsIENvdXJzZVJlc3BvbnNlIH0gZnJvbSAnQC90eXBlcy9jb3Vyc2VzJztcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuXG5jb25zdCBDT0xMRUNUSU9OX05BTUUgPSAnY291cnNlcyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjbGVhbiBkYXRhIGJlZm9yZSBzZW5kaW5nIHRvIEZpcmVzdG9yZVxuY29uc3QgY2xlYW5Db3Vyc2VEYXRhID0gKGRhdGE6IGFueSkgPT4ge1xuICBjb25zdCBjbGVhbmVkOiBhbnkgPSB7fTtcbiAgXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgLy8gU2tpcCB1bmRlZmluZWQgdmFsdWVzIGFuZCBmdW5jdGlvbnNcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIENvbnZlcnQgZW1wdHkgc3RyaW5ncyB0byBudWxsIGZvciBvcHRpb25hbCBmaWVsZHNcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSAnJyAmJiBcbiAgICAgICAgICBbJ3BheW1lbnRMaW5rJywgJ2JhY2tncm91bmRJbWFnZScsICdjZXJ0aWZpY2F0ZUltYWdlJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjbGVhbmVkW2tleV0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW5lZFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gY2xlYW5lZDtcbn07XG5cbmV4cG9ydCBjbGFzcyBDb3Vyc2VTZXJ2aWNlIHtcbiAgLy8gQ3JlYXRlIGEgbmV3IGNvdXJzZVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlQ291cnNlKGNvdXJzZURhdGE6IE5ld0NvdXJzZSk6IFByb21pc2U8Q291cnNlUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY291cnNlSWQgPSB1dWlkdjQoKTtcbiAgICAgIFxuICAgICAgY29uc3QgY291cnNlV2l0aE1ldGFkYXRhID0ge1xuICAgICAgICAuLi5jb3Vyc2VEYXRhLFxuICAgICAgICBfaWQ6IGNvdXJzZUlkLFxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICBzdGF0dXM6IGNvdXJzZURhdGEuc3RhdHVzIHx8ICdkcmFmdCcsXG4gICAgICAgIC8vIEVuc3VyZSB0aGVzZSBmaWVsZHMgYXJlIG51bWJlcnNcbiAgICAgICAgcmF0aW5nOiBOdW1iZXIoY291cnNlRGF0YS5yYXRpbmcpIHx8IDAsXG4gICAgICAgIHRvdGFsUmF0aW5nczogTnVtYmVyKGNvdXJzZURhdGEudG90YWxSYXRpbmdzKSB8fCAwLFxuICAgICAgICBlbnJvbGxlZFN0dWRlbnRzOiBOdW1iZXIoY291cnNlRGF0YS5lbnJvbGxlZFN0dWRlbnRzKSB8fCAwLFxuICAgICAgICBwcmljZTogTnVtYmVyKGNvdXJzZURhdGEucHJpY2UpIHx8IDAsXG4gICAgICAgIG9yaWdpbmFsUHJpY2U6IE51bWJlcihjb3Vyc2VEYXRhLm9yaWdpbmFsUHJpY2UpIHx8IDAsXG4gICAgICAgIC8vIEVuc3VyZSBhcnJheXMgYXJlIHByb3Blcmx5IGluaXRpYWxpemVkXG4gICAgICAgIGxlYXJuaW5nT3V0Y29tZXM6IEFycmF5LmlzQXJyYXkoY291cnNlRGF0YS5sZWFybmluZ091dGNvbWVzKSA/IGNvdXJzZURhdGEubGVhcm5pbmdPdXRjb21lcyA6IFtdLFxuICAgICAgICBmZWF0dXJlczogQXJyYXkuaXNBcnJheShjb3Vyc2VEYXRhLmZlYXR1cmVzKSA/IGNvdXJzZURhdGEuZmVhdHVyZXMgOiBbXSxcbiAgICAgICAgc2tpbGxzOiBBcnJheS5pc0FycmF5KGNvdXJzZURhdGEuc2tpbGxzKSA/IGNvdXJzZURhdGEuc2tpbGxzIDogW10sXG4gICAgICAgIHJlcXVpcmVtZW50czogQXJyYXkuaXNBcnJheShjb3Vyc2VEYXRhLnJlcXVpcmVtZW50cykgPyBjb3Vyc2VEYXRhLnJlcXVpcmVtZW50cyA6IFtdLFxuICAgICAgICBtb2R1bGU6IEFycmF5LmlzQXJyYXkoY291cnNlRGF0YS5tb2R1bGUpID8gY291cnNlRGF0YS5tb2R1bGUgOiBbXSxcbiAgICAgICAgaGlnaGxpZ2h0czogQXJyYXkuaXNBcnJheShjb3Vyc2VEYXRhLmhpZ2hsaWdodHMpID8gY291cnNlRGF0YS5oaWdobGlnaHRzIDogW10sXG4gICAgICAgIHByb2plY3Q6IEFycmF5LmlzQXJyYXkoY291cnNlRGF0YS5wcm9qZWN0KSA/IGNvdXJzZURhdGEucHJvamVjdCA6IFtdLFxuICAgICAgICBwcm9ncmFtRm9yOiBBcnJheS5pc0FycmF5KGNvdXJzZURhdGEucHJvZ3JhbUZvcikgPyBjb3Vyc2VEYXRhLnByb2dyYW1Gb3IgOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIC8vIENsZWFuIHRoZSBkYXRhIGJlZm9yZSBzZW5kaW5nXG4gICAgICBjb25zdCBjbGVhbmVkRGF0YSA9IGNsZWFuQ291cnNlRGF0YShjb3Vyc2VXaXRoTWV0YWRhdGEpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgY291cnNlIHdpdGggZGF0YTonLCBjbGVhbmVkRGF0YSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCBDT0xMRUNUSU9OX05BTUUpLCBjbGVhbmVkRGF0YSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNyZWF0ZWRDb3Vyc2U6IENvdXJzZSA9IHtcbiAgICAgICAgLi4uY2xlYW5lZERhdGEsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9IGFzIENvdXJzZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogY3JlYXRlZENvdXJzZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjb3Vyc2U6JywgZXJyb3IpO1xuICAgICAgaGFuZGxlRmlyZXN0b3JlRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gY3JlYXRlIGNvdXJzZSdcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGFsbCBjb3Vyc2VzXG4gIHN0YXRpYyBhc3luYyBnZXRBbGxDb3Vyc2VzKCk6IFByb21pc2U8Q291cnNlc1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHEgPSBxdWVyeShjb2xsZWN0aW9uKGRiLCBDT0xMRUNUSU9OX05BTUUpLCBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpKTtcbiAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgICAgXG4gICAgICBjb25zdCBjb3Vyc2VzOiBDb3Vyc2VbXSA9IFtdO1xuICAgICAgcXVlcnlTbmFwc2hvdC5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGRvYy5kYXRhKCk7XG4gICAgICAgIGNvdXJzZXMucHVzaCh7XG4gICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0RhdGUoKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IGRhdGEudXBkYXRlZEF0Py50b0RhdGUoKVxuICAgICAgICB9IGFzIENvdXJzZSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogY291cnNlc1xuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb3Vyc2VzOicsIGVycm9yKTtcbiAgICAgIGhhbmRsZUZpcmVzdG9yZUVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGZldGNoIGNvdXJzZXMnXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBjb3Vyc2UgYnkgSURcbiAgc3RhdGljIGFzeW5jIGdldENvdXJzZUJ5SWQoY291cnNlSWQ6IHN0cmluZyk6IFByb21pc2U8Q291cnNlUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcSA9IHF1ZXJ5KGNvbGxlY3Rpb24oZGIsIENPTExFQ1RJT05fTkFNRSksIHdoZXJlKCdfaWQnLCAnPT0nLCBjb3Vyc2VJZCkpO1xuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICBcbiAgICAgIGlmIChxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdDb3Vyc2Ugbm90IGZvdW5kJ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkb2MgPSBxdWVyeVNuYXBzaG90LmRvY3NbMF07XG4gICAgICBjb25zdCBkYXRhID0gZG9jLmRhdGEoKTtcbiAgICAgIGNvbnN0IGNvdXJzZTogQ291cnNlID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICBjcmVhdGVkQXQ6IGRhdGEuY3JlYXRlZEF0Py50b0RhdGUoKSxcbiAgICAgICAgdXBkYXRlZEF0OiBkYXRhLnVwZGF0ZWRBdD8udG9EYXRlKClcbiAgICAgIH0gYXMgQ291cnNlO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBkYXRhOiBjb3Vyc2VcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY291cnNlOicsIGVycm9yKTtcbiAgICAgIGhhbmRsZUZpcmVzdG9yZUVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGZldGNoIGNvdXJzZSdcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGNvdXJzZVxuICBzdGF0aWMgYXN5bmMgdXBkYXRlQ291cnNlKGNvdXJzZUlkOiBzdHJpbmcsIGNvdXJzZURhdGE6IFBhcnRpYWw8Q291cnNlPik6IFByb21pc2U8Q291cnNlUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcSA9IHF1ZXJ5KGNvbGxlY3Rpb24oZGIsIENPTExFQ1RJT05fTkFNRSksIHdoZXJlKCdfaWQnLCAnPT0nLCBjb3Vyc2VJZCkpO1xuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICBcbiAgICAgIGlmIChxdWVyeVNuYXBzaG90LmVtcHR5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdDb3Vyc2Ugbm90IGZvdW5kJ1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkb2NSZWYgPSBxdWVyeVNuYXBzaG90LmRvY3NbMF0ucmVmO1xuICAgICAgXG4gICAgICBjb25zdCB1cGRhdGVEYXRhID0ge1xuICAgICAgICAuLi5jb3Vyc2VEYXRhLFxuICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICAvLyBFbnN1cmUgbnVtZXJpYyBmaWVsZHMgYXJlIHByb3Blcmx5IHR5cGVkXG4gICAgICAgIC4uLihjb3Vyc2VEYXRhLnJhdGluZyAhPT0gdW5kZWZpbmVkICYmIHsgcmF0aW5nOiBOdW1iZXIoY291cnNlRGF0YS5yYXRpbmcpIH0pLFxuICAgICAgICAuLi4oY291cnNlRGF0YS50b3RhbFJhdGluZ3MgIT09IHVuZGVmaW5lZCAmJiB7IHRvdGFsUmF0aW5nczogTnVtYmVyKGNvdXJzZURhdGEudG90YWxSYXRpbmdzKSB9KSxcbiAgICAgICAgLi4uKGNvdXJzZURhdGEuZW5yb2xsZWRTdHVkZW50cyAhPT0gdW5kZWZpbmVkICYmIHsgZW5yb2xsZWRTdHVkZW50czogTnVtYmVyKGNvdXJzZURhdGEuZW5yb2xsZWRTdHVkZW50cykgfSksXG4gICAgICAgIC4uLihjb3Vyc2VEYXRhLnByaWNlICE9PSB1bmRlZmluZWQgJiYgeyBwcmljZTogTnVtYmVyKGNvdXJzZURhdGEucHJpY2UpIH0pLFxuICAgICAgICAuLi4oY291cnNlRGF0YS5vcmlnaW5hbFByaWNlICE9PSB1bmRlZmluZWQgJiYgeyBvcmlnaW5hbFByaWNlOiBOdW1iZXIoY291cnNlRGF0YS5vcmlnaW5hbFByaWNlKSB9KSxcbiAgICAgIH07XG5cbiAgICAgIC8vIENsZWFuIHRoZSBkYXRhIGJlZm9yZSBzZW5kaW5nXG4gICAgICBjb25zdCBjbGVhbmVkRGF0YSA9IGNsZWFuQ291cnNlRGF0YSh1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGNvdXJzZSB3aXRoIGRhdGE6JywgY2xlYW5lZERhdGEpO1xuXG4gICAgICBhd2FpdCB1cGRhdGVEb2MoZG9jUmVmLCBjbGVhbmVkRGF0YSk7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZWRDb3Vyc2U6IENvdXJzZSA9IHtcbiAgICAgICAgLi4uY291cnNlRGF0YSxcbiAgICAgICAgX2lkOiBjb3Vyc2VJZCxcbiAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpXG4gICAgICB9IGFzIENvdXJzZTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZGF0YTogdXBkYXRlZENvdXJzZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBjb3Vyc2U6JywgZXJyb3IpO1xuICAgICAgaGFuZGxlRmlyZXN0b3JlRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdXBkYXRlIGNvdXJzZSdcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIGNvdXJzZVxuICBzdGF0aWMgYXN5bmMgZGVsZXRlQ291cnNlKGNvdXJzZUlkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBxID0gcXVlcnkoY29sbGVjdGlvbihkYiwgQ09MTEVDVElPTl9OQU1FKSwgd2hlcmUoJ19pZCcsICc9PScsIGNvdXJzZUlkKSk7XG4gICAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICAgIFxuICAgICAgaWYgKHF1ZXJ5U25hcHNob3QuZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ0NvdXJzZSBub3QgZm91bmQnXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRvY1JlZiA9IHF1ZXJ5U25hcHNob3QuZG9jc1swXS5yZWY7XG4gICAgICBhd2FpdCBkZWxldGVEb2MoZG9jUmVmKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBjb3Vyc2U6JywgZXJyb3IpO1xuICAgICAgaGFuZGxlRmlyZXN0b3JlRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZGVsZXRlIGNvdXJzZSdcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gVXBsb2FkIGltYWdlIHdpdGggYmV0dGVyIGVycm9yIGhhbmRsaW5nXG4gIHN0YXRpYyBhc3luYyB1cGxvYWRJbWFnZShmaWxlOiBGaWxlLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgdXJsPzogc3RyaW5nOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFZhbGlkYXRlIGZpbGVcbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdObyBmaWxlIHByb3ZpZGVkJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZmlsZS5zaXplID4gNSAqIDEwMjQgKiAxMDI0KSB7IC8vIDVNQiBsaW1pdFxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdGaWxlIHNpemUgbXVzdCBiZSBsZXNzIHRoYW4gNU1CJyB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBhbGxvd2VkVHlwZXMgPSBbJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvcG5nJywgJ2ltYWdlL3dlYnAnXTtcbiAgICAgIGlmICghYWxsb3dlZFR5cGVzLmluY2x1ZGVzKGZpbGUudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnT25seSBKUEVHLCBQTkcsIGFuZCBXZWJQIGltYWdlcyBhcmUgYWxsb3dlZCcgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZmlsZW5hbWUgPSBgJHtEYXRlLm5vdygpfV8ke2ZpbGUubmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOS4tXS9nLCAnXycpfWA7XG4gICAgICBjb25zdCBzdG9yYWdlUmVmID0gcmVmKHN0b3JhZ2UsIGAke3BhdGh9LyR7ZmlsZW5hbWV9YCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdVcGxvYWRpbmcgaW1hZ2U6JywgZmlsZW5hbWUpO1xuICAgICAgXG4gICAgICBhd2FpdCB1cGxvYWRCeXRlcyhzdG9yYWdlUmVmLCBmaWxlKTtcbiAgICAgIGNvbnN0IGRvd25sb2FkVVJMID0gYXdhaXQgZ2V0RG93bmxvYWRVUkwoc3RvcmFnZVJlZik7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHVybDogZG93bmxvYWRVUkxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBsb2FkaW5nIGltYWdlOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHVwbG9hZCBpbWFnZSdcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRGVsZXRlIGltYWdlXG4gIHN0YXRpYyBhc3luYyBkZWxldGVJbWFnZShpbWFnZVVybDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW1hZ2VSZWYgPSByZWYoc3RvcmFnZSwgaW1hZ2VVcmwpO1xuICAgICAgYXdhaXQgZGVsZXRlT2JqZWN0KGltYWdlUmVmKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBpbWFnZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBkZWxldGUgaW1hZ2UnXG4gICAgICB9O1xuICAgIH1cbiAgfVxufSJdLCJuYW1lcyI6WyJjb2xsZWN0aW9uIiwiYWRkRG9jIiwidXBkYXRlRG9jIiwiZGVsZXRlRG9jIiwiZ2V0RG9jcyIsInF1ZXJ5Iiwib3JkZXJCeSIsInNlcnZlclRpbWVzdGFtcCIsIndoZXJlIiwicmVmIiwidXBsb2FkQnl0ZXMiLCJnZXREb3dubG9hZFVSTCIsImRlbGV0ZU9iamVjdCIsImRiIiwic3RvcmFnZSIsImhhbmRsZUZpcmVzdG9yZUVycm9yIiwidjQiLCJ1dWlkdjQiLCJDT0xMRUNUSU9OX05BTUUiLCJjbGVhbkNvdXJzZURhdGEiLCJkYXRhIiwiY2xlYW5lZCIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwiQ291cnNlU2VydmljZSIsImNyZWF0ZUNvdXJzZSIsImNvdXJzZURhdGEiLCJjb3Vyc2VJZCIsImNvdXJzZVdpdGhNZXRhZGF0YSIsIl9pZCIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsInN0YXR1cyIsInJhdGluZyIsIk51bWJlciIsInRvdGFsUmF0aW5ncyIsImVucm9sbGVkU3R1ZGVudHMiLCJwcmljZSIsIm9yaWdpbmFsUHJpY2UiLCJsZWFybmluZ091dGNvbWVzIiwiQXJyYXkiLCJpc0FycmF5IiwiZmVhdHVyZXMiLCJza2lsbHMiLCJyZXF1aXJlbWVudHMiLCJtb2R1bGUiLCJoaWdobGlnaHRzIiwicHJvamVjdCIsInByb2dyYW1Gb3IiLCJjbGVhbmVkRGF0YSIsImNvbnNvbGUiLCJsb2ciLCJkb2NSZWYiLCJjcmVhdGVkQ291cnNlIiwiRGF0ZSIsInN1Y2Nlc3MiLCJlcnJvciIsIm1lc3NhZ2UiLCJnZXRBbGxDb3Vyc2VzIiwicSIsInF1ZXJ5U25hcHNob3QiLCJjb3Vyc2VzIiwiZm9yRWFjaCIsImRvYyIsInB1c2giLCJ0b0RhdGUiLCJnZXRDb3Vyc2VCeUlkIiwiZW1wdHkiLCJkb2NzIiwiY291cnNlIiwidXBkYXRlQ291cnNlIiwidXBkYXRlRGF0YSIsInVwZGF0ZWRDb3Vyc2UiLCJkZWxldGVDb3Vyc2UiLCJ1cGxvYWRJbWFnZSIsImZpbGUiLCJwYXRoIiwic2l6ZSIsImFsbG93ZWRUeXBlcyIsInR5cGUiLCJmaWxlbmFtZSIsIm5vdyIsIm5hbWUiLCJyZXBsYWNlIiwic3RvcmFnZVJlZiIsImRvd25sb2FkVVJMIiwidXJsIiwiZGVsZXRlSW1hZ2UiLCJpbWFnZVVybCIsImltYWdlUmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/courseService.ts\n"));

/***/ })

});